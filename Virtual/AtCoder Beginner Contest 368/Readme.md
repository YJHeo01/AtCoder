[https://atcoder.jp/contests/abc368/submissions/me](https://atcoder.jp/contests/abc368/submissions?f.Task=&f.LanguageName=&f.Status=&f.User=sk14cj)

퍼포먼스 계산기를 돌려보 무려 1143이 나왔다

코포보단 앳코더가 나와 더 잘맞는듯....

A : n-k번째부터 n번째 원소를 출력하고, 이후 1번째부터 n-k-1번째까지 출력해주면 된다.

B : 배열을 계속 내림차순으로 정렬해주고, a[0] -= 1; a[1] -= 1을 하는 시뮬레이션을 반복문을 통해 구현한다. 이때, 두 번째로 큰 값이 0이하가 될 때 끝내준다. Ai의 최대값이 100이기에 할 수 있었던 시뮬레이션

C : t가 3 증가할 때마다 데이지 5를 줄 수 있다는 점을 파악하고 수학적 발상을 통해 해결 가능한 문제

D : 처음에는 최소공통조상을 생각했었는데, 생각해보니 한 노드를 루트로 잡고, 뎁스가 가장 작은 순서대로 루트를 찾아가다가 이미 꼭 필요한 노드가 된 노드를 방문할 경우 종료하는 dfs를 사용하면 작은 시간복잡도로 해결 가능한 문제로 보여서 이대로 구현했고, 통과했다.

E, F, G : 4솔을 하니 갑자기 게을러져서 제대로 안건드렸다 ㅋㅋ 업솔빙 해야징
